# nanobot ä»£ç æ¶æ„åˆ†ææ–‡æ¡£

> ç›®æ ‡è¯»è€…ï¼šJS å°ç™½
> æ–‡æ¡£ç›®æ ‡ï¼šè¯¦ç»†è§£é‡Š nanobot å„æ¨¡å—çš„ä»£ç å®ç°ï¼Œå¸®åŠ©ç†è§£ TypeScript/JavaScript é¡¹ç›®ç»“æ„

---

## 1. é¡¹ç›®æ•´ä½“ç»“æ„

### 1.1 ç›®å½•ç»„ç»‡

```
nanobot/
â”œâ”€â”€ src/                          # æºä»£ç ç›®å½•
â”‚   â”œâ”€â”€ agent/                    # ğŸ§  Agent æ ¸å¿ƒé€»è¾‘
â”‚   â”‚   â”œâ”€â”€ loop.ts              #    Agent å¾ªç¯å¼•æ“ï¼ˆæ ¸å¿ƒï¼‰
â”‚   â”‚   â”œâ”€â”€ context.ts           #    ä¸Šä¸‹æ–‡æ„å»ºå™¨
â”‚   â”‚   â”œâ”€â”€ memory.ts           #    è®°å¿†å­˜å‚¨
â”‚   â”‚   â”œâ”€â”€ skills.ts           #    æŠ€èƒ½åŠ è½½å™¨
â”‚   â”‚   â”œâ”€â”€ subagent.ts         #    å­ä»»åŠ¡æ‰§è¡Œ
â”‚   â”‚   â””â”€â”€ types.ts            #    ç±»å‹å®šä¹‰
â”‚   â”‚
â”‚   â”œâ”€â”€ providers/               # ğŸ¤– LLM æä¾›å•†
â”‚   â”‚   â”œâ”€â”€ base.ts             #    åŸºç¡€æ¥å£å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ anthropic.ts        #    Anthropic (Claude) å®ç°
â”‚   â”‚   â””â”€â”€ openai.ts           #    OpenAI (GPT) å®ç°
â”‚   â”‚
â”‚   â”œâ”€â”€ tools/                   # ğŸ› ï¸ å·¥å…·é›†
â”‚   â”‚   â”œâ”€â”€ registry.ts         #    å·¥å…·æ³¨å†Œä¸­å¿ƒ
â”‚   â”‚   â”œâ”€â”€ shell.ts            #    æ‰§è¡Œ Shell å‘½ä»¤
â”‚   â”‚   â”œâ”€â”€ web.ts              #    ç½‘é¡µæœç´¢/è·å–
â”‚   â”‚   â”œâ”€â”€ filesystem.ts       #    æ–‡ä»¶æ“ä½œ
â”‚   â”‚   â”œâ”€â”€ spawn.ts            #    å¯åŠ¨å­è¿›ç¨‹
â”‚   â”‚   â””â”€â”€ message.ts          #    å‘é€æ¶ˆæ¯
â”‚   â”‚
â”‚   â”œâ”€â”€ channels/                # ğŸ“± é€šé“é›†æˆï¼ˆé£ä¹¦ï¼‰
â”‚   â”‚   â”œâ”€â”€ base.ts             #    é€šé“åŸºç±»
â”‚   â”‚   â”œâ”€â”€ manager.ts          #    é€šé“ç®¡ç†å™¨
â”‚   â”‚   â””â”€â”€ feishu.ts           #    é£ä¹¦å®ç°
â”‚   â”‚
â”‚   â”œâ”€â”€ bus/                     # ğŸšŒ æ¶ˆæ¯æ€»çº¿
â”‚   â”‚   â”œâ”€â”€ queue.ts            #    æ¶ˆæ¯é˜Ÿåˆ—
â”‚   â”‚   â””â”€â”€ events.ts           #    äº‹ä»¶å®šä¹‰
â”‚   â”‚
â”‚   â”œâ”€â”€ session/                 # ğŸ’¬ ä¼šè¯ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ manager.ts          #    ä¼šè¯ç®¡ç†å™¨
â”‚   â”‚   â”œâ”€â”€ session.ts          #    ä¼šè¯ç±»
â”‚   â”‚   â””â”€â”€ types.ts            #    ç±»å‹å®šä¹‰
â”‚   â”‚
â”‚   â”œâ”€â”€ cron/                    # â° å®šæ—¶ä»»åŠ¡
â”‚   â”‚   â”œâ”€â”€ service.ts          #    å®šæ—¶ä»»åŠ¡æœåŠ¡
â”‚   â”‚   â”œâ”€â”€ types.ts            #    ç±»å‹å®šä¹‰
â”‚   â”‚   â””â”€â”€ index.ts            #    å…¥å£
â”‚   â”‚
â”‚   â”œâ”€â”€ heartbeat/               # ğŸ’“ å¿ƒè·³æœåŠ¡
â”‚   â”‚   â”œâ”€â”€ service.ts          #    å¿ƒè·³æœåŠ¡å®ç°
â”‚   â”‚   â””â”€â”€ index.ts            #    å…¥å£
â”‚   â”‚
â”‚   â”œâ”€â”€ config/                  # âš™ï¸ é…ç½®ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ loader.ts           #    é…ç½®åŠ è½½/ä¿å­˜
â”‚   â”‚   â”œâ”€â”€ schema.ts           #    é…ç½® schema
â”‚   â”‚   â””â”€â”€ index.ts            #    å…¥å£
â”‚   â”‚
â”‚   â”œâ”€â”€ cli/                     # ğŸ–¥ï¸ å‘½ä»¤è¡Œ
â”‚   â”‚   â””â”€â”€ commands.ts         #    æ‰€æœ‰ CLI å‘½ä»¤
â”‚   â”‚
â”‚   â””â”€â”€ utils/                   # ğŸ”§ å·¥å…·å‡½æ•°
â”‚       â”œâ”€â”€ helpers.ts           #    è¾…åŠ©å‡½æ•°
â”‚       â””â”€â”€ index.ts            #    å…¥å£
â”‚
â”œâ”€â”€ package.json                 # é¡¹ç›®é…ç½®
â””â”€â”€ tsconfig.json               # TypeScript é…ç½®
```

### 1.2 æ¨¡å—ä¾èµ–å…³ç³»å›¾

```mermaid
graph TD
    subgraph CLI å±‚
        CLI[cli/commands.ts]
    end
    
    subgraph æ ¸å¿ƒå±‚
        Agent[agent/loop.ts]
        Context[agent/context.ts]
        Memory[agent/memory.ts]
        Skills[agent/skills.ts]
    end
    
    subgraph æœåŠ¡å±‚
        Bus[bus/queue.ts]
        Channel[channels/manager.ts]
        Cron[cron/service.ts]
        Heartbeat[heartbeat/service.ts]
        Session[session/manager.ts]
    end
    
    subgraph åº•å±‚
        Provider[providers/*.ts]
        Tools[tools/registry.ts]
        Config[config/loader.ts]
    end
    
    CLI --> Agent
    CLI --> Config
    
    Agent --> Context
    Agent --> Skills
    Agent --> Session
    Agent --> Provider
    Agent --> Tools
    
    Channel --> Bus
    Bus --> Agent
    Cron --> Agent
    Heartbeat --> Agent
```

---

## 2. æ ¸å¿ƒæ¨¡å—è¯¦è§£

### 2.1 Agent å¾ªç¯ (Agent Loop)

**æ–‡ä»¶ä½ç½®**: `src/agent/loop.ts`

#### 2.1.1 ä»€ä¹ˆæ˜¯ Agent Loopï¼Ÿ

Agent Loop æ˜¯ nanobot çš„"å¿ƒè„"ï¼Œå®ƒçš„æ ¸å¿ƒä»»åŠ¡æ˜¯ï¼š
1. æ¥æ”¶ç”¨æˆ·æ¶ˆæ¯
2. è°ƒç”¨ LLMï¼ˆå¤§å‹è¯­è¨€æ¨¡å‹ï¼‰å¤„ç†æ¶ˆæ¯
3. å¦‚æœ LLM è¿”å›å·¥å…·è°ƒç”¨ï¼Œæ‰§è¡Œç›¸åº”å·¥å…·
4. å°†å·¥å…·ç»“æœè¿”å›ç»™ LLM
5. é‡å¤æ­¥éª¤ 2-4 ç›´åˆ°å¾—åˆ°æœ€ç»ˆå›å¤

#### 2.1.2 ä»£ç é€è¡Œè§£æ

```typescript
// ============================================================
// å¯¼å…¥ä¾èµ–æ¨¡å—
// ============================================================
import { ToolRegistry } from "../tools/registry";        // å·¥å…·æ³¨å†Œä¸­å¿ƒ
import { ContextBuilder } from "./context";              // ä¸Šä¸‹æ–‡æ„å»ºå™¨
import { SkillsLoader } from "./skills";                 // æŠ€èƒ½åŠ è½½å™¨
import { WebSearchTool, WebFetchTool, ReadFileTool, 
         WriteFileTool, EditFileTool, ListDirTool, 
         ExecTool, MessageTool, SpawnTool } from "../tools";  // æ‰€æœ‰å†…ç½®å·¥å…·
import type { InboundMessage, OutboundMessage } from "./types";
import type { LLMProvider, Message, ChatOptions } from "../providers/base";
import { SessionManager } from "../session/manager";     // ä¼šè¯ç®¡ç†

// ============================================================
// AgentLoop ç±» - æ ¸å¿ƒå¾ªç¯å¼•æ“
// ============================================================
export class AgentLoop {
  // ç§æœ‰æˆå‘˜å˜é‡
  private tools: ToolRegistry;           // å·¥å…·æ³¨å†Œä¸­å¿ƒå®ä¾‹
  private context: ContextBuilder;       // ä¸Šä¸‹æ–‡æ„å»ºå™¨å®ä¾‹
  private sessions: SessionManager;      // ä¼šè¯ç®¡ç†å™¨å®ä¾‹
  private model: string;                  // ä½¿ç”¨çš„æ¨¡å‹åç§°
  private maxIterations: number;          // æœ€å¤§å¾ªç¯æ¬¡æ•°ï¼ˆé˜²æ­¢æ— é™å¾ªç¯ï¼‰
  private verbose: boolean = true;        // æ˜¯å¦è¾“å‡ºè¯¦ç»†æ—¥å¿—
  
  // ============================================================
  // æ„é€ å‡½æ•° - åˆå§‹åŒ– AgentLoop
  // å‚æ•°:
  //   - provider: LLM æä¾›å•†å®ä¾‹ï¼ˆAnthropic æˆ– OpenAIï¼‰
  //   - workspace: å·¥ä½œç©ºé—´è·¯å¾„
  //   - options: å¯é€‰é…ç½®ï¼ˆå¦‚æ¨¡å‹åç§°ã€æœ€å¤§è¿­ä»£æ¬¡æ•°ç­‰ï¼‰
  // ============================================================
  constructor(
    private provider: LLMProvider,       // LLM æä¾›å•†
    workspace: string,                    // å·¥ä½œç©ºé—´è·¯å¾„
    options?: AgentLoopOptions            // å¯é€‰é…ç½®
  ) {
    console.debug('[AgentLoop] Creating AgentLoop...');
    console.debug('[AgentLoop] Provider:', provider.constructor.name);
    console.debug('[AgentLoop] Model:', options?.model ?? provider.getDefaultModel());
    
    // 1. åˆ›å»ºå·¥å…·æ³¨å†Œä¸­å¿ƒ
    this.tools = new ToolRegistry();
    
    // 2. åˆ›å»ºä¼šè¯ç®¡ç†å™¨
    this.sessions = new SessionManager(workspace);
    
    // 3. è®¾ç½®æ¨¡å‹åç§°ï¼ˆä½¿ç”¨é…ç½®æˆ–é»˜è®¤å€¼ï¼‰
    this.model = options?.model ?? provider.getDefaultModel();
    
    // 4. è®¾ç½®æœ€å¤§è¿­ä»£æ¬¡æ•°ï¼ˆé»˜è®¤ 20 æ¬¡ï¼‰
    this.maxIterations = options?.maxIterations ?? 20;
    
    // 5. åˆ›å»ºæŠ€èƒ½åŠ è½½å™¨å¹¶æ„å»ºä¸Šä¸‹æ–‡
    const builtinSkillsDir = process.env.NANOBOT_BUILTIN_SKILLS 
      || join(__dirname, "../skills");
    const skillsLoader = new SkillsLoader(workspace, builtinSkillsDir);
    
    // 6. åˆ›å»ºä¸Šä¸‹æ–‡æ„å»ºå™¨ï¼ˆä¼ å…¥æŠ€èƒ½åŠ è½½å™¨ï¼‰
    this.context = new ContextBuilder(workspace, null, skillsLoader);
    
    // 7. æ³¨å†Œå†…ç½®å·¥å…·
    this._registerDefaultTools();
    
    // 8. æ³¨å†Œ MCP å·¥å…·ï¼ˆå½“å‰ä¸ºç©ºå®ç°ï¼‰
    this._registerMcpTools();
  }

  // ============================================================
  // æ³¨å†Œå†…ç½®å·¥å…·
  // è¿™äº›å·¥å…·ä¼šåœ¨æ¯æ¬¡ AgentLoop åˆ›å»ºæ—¶è‡ªåŠ¨æ³¨å†Œ
  // ============================================================
  private _registerDefaultTools(): void {
    this.tools.register(new WebSearchTool());   // ç½‘é¡µæœç´¢
    this.tools.register(new WebFetchTool());    // ç½‘é¡µè·å–
    this.tools.register(new ReadFileTool());     // è¯»æ–‡ä»¶
    this.tools.register(new WriteFileTool());    // å†™æ–‡ä»¶
    this.tools.register(new EditFileTool());     // ç¼–è¾‘æ–‡ä»¶
    this.tools.register(new ListDirTool());      // åˆ—å‡ºç›®å½•
    this.tools.register(new ExecTool());         // æ‰§è¡Œå‘½ä»¤
    this.tools.register(new MessageTool());      // å‘é€æ¶ˆæ¯
    this.tools.register(new SpawnTool());        // å¯åŠ¨å­è¿›ç¨‹
  }

  // ============================================================
  // æ ¸å¿ƒæ–¹æ³•: å¤„ç†ç›´æ¥æ¶ˆæ¯
  // è¿™æ˜¯ç”¨æˆ·ä¸ Agent å¯¹è¯çš„ä¸»è¦å…¥å£
  //
  // å‚æ•°:
  //   - content: ç”¨æˆ·å‘é€çš„æ¶ˆæ¯å†…å®¹
  //   - sessionKey: ä¼šè¯æ ‡è¯†ç¬¦ï¼ˆç”¨äºåŒºåˆ†ä¸åŒå¯¹è¯ï¼‰
  //
  // è¿”å›:
  //   - Agent çš„å›å¤å†…å®¹
  // ============================================================
  async processDirect(
    content: string,                      // ç”¨æˆ·æ¶ˆæ¯
    sessionKey: string = "cli:direct"     // ä¼šè¯é”®ï¼Œé»˜è®¤ CLI ç›´è¿
  ): Promise<string> {
    this._log('info', '=== processDirect() called ===');
    this._log('info', 'Session: %s, Content: "%s"', sessionKey, content.substring(0, 50));
    
    // 1. è·å–æˆ–åˆ›å»ºä¼šè¯ï¼ˆä¼šè¯ä¿å­˜å¯¹è¯å†å²ï¼‰
    const session = this.sessions.getOrCreate(sessionKey);
    
    // 2. æ„å»ºæ¶ˆæ¯åˆ—è¡¨
    // æ¶ˆæ¯æ ¼å¼: [ç³»ç»Ÿæç¤ºè¯, å†å²æ¶ˆæ¯, å½“å‰ç”¨æˆ·æ¶ˆæ¯]
    const messages: Message[] = [
      {
        role: "system",  // ç³»ç»Ÿæ¶ˆæ¯ï¼ˆAgent çš„è¡Œä¸ºè§„èŒƒï¼‰
        content: this.context.buildSystemPrompt()
      },
      // å±•å¼€å†å²æ¶ˆæ¯ï¼ˆä¹‹å‰çš„å¯¹è¯è®°å½•ï¼‰
      ...session.getHistory().map(m => ({
        role: m.role as "user" | "assistant" | "system",
        content: m.content
      })),
      // å½“å‰ç”¨æˆ·æ¶ˆæ¯
      {
        role: "user",
        content
      }
    ];
    
    // 3. å¾ªç¯è°ƒç”¨ LLM å’Œå·¥å…·
    let iteration = 0;           // å½“å‰å¾ªç¯æ¬¡æ•°
    let finalContent: string | null = null;  // æœ€ç»ˆå›å¤å†…å®¹
    
    // å¾ªç¯ç›´åˆ°: è¾¾åˆ°æœ€å¤§æ¬¡æ•° æˆ– LLM ä¸å†è¯·æ±‚å·¥å…·è°ƒç”¨
    while (iteration < this.maxIterations) {
      iteration++;
      
      // ---------------- è°ƒç”¨ LLM ----------------
      const response = await this.provider.chat({
        messages,                        // å‘é€æ¶ˆæ¯å†å²
        tools: this.tools.get_definitions(),  // å‘é€å·¥å…·å®šä¹‰
        model: this.model                // ä½¿ç”¨çš„æ¨¡å‹
      });
      
      // ---------------- æ£€æŸ¥å·¥å…·è°ƒç”¨ ----------------
      if (response.toolCalls && response.toolCalls.length > 0) {
        // 1. å°† LLM çš„å›å¤ï¼ˆåŒ…å«å·¥å…·è°ƒç”¨ï¼‰æ·»åŠ åˆ°æ¶ˆæ¯å†å²
        messages.push({
          role: "assistant",
          content: response.content ?? "",
          toolCallId: response.toolCalls[0].id,
          toolName: response.toolCalls[0].name
        } as Message);
        
        // 2. é€ä¸ªæ‰§è¡Œå·¥å…·è°ƒç”¨
        for (const toolCall of response.toolCalls) {
          // æ‰§è¡Œå·¥å…·å¹¶è·å–ç»“æœ
          const result = await this.tools.execute(
            toolCall.name,              // å·¥å…·åç§°
            toolCall.arguments          // å·¥å…·å‚æ•°
          );
          
          // 3. å°†å·¥å…·æ‰§è¡Œç»“æœæ·»åŠ åˆ°æ¶ˆæ¯å†å²
          messages.push({
            role: "tool",               // å·¥å…·è§’è‰²
            content: result,            // å·¥å…·è¿”å›ç»“æœ
            toolCallId: toolCall.id,    // å·¥å…·è°ƒç”¨ ID
            toolName: toolCall.name     // å·¥å…·åç§°
          } as Message);
        }
      } else {
        // LLM æ²¡æœ‰è¯·æ±‚å·¥å…·è°ƒç”¨ï¼Œè¯´æ˜å·²ç»å¾—åˆ°æœ€ç»ˆå›å¤
        finalContent = response.content;
        break;  // é€€å‡ºå¾ªç¯
      }
    }
    
    // 4. ä¿å­˜ä¼šè¯å†å²ï¼ˆç”¨äºä¸‹æ¬¡å¯¹è¯ï¼‰
    session.addMessage("user", content);
    session.addMessage("assistant", finalContent ?? "");
    this.sessions.save(session);
    
    // 5. è¿”å›æœ€ç»ˆå›å¤
    return finalContent ?? "No response";
  }
}
```

#### 2.1.3 Agent Loop å·¥ä½œæµç¨‹å›¾

```mermaid
sequenceDiagram
    participant ç”¨æˆ·
    participant AgentLoop
    participant ä¼šè¯ç®¡ç†
    participant LLM
    participant å·¥å…·æ³¨å†Œ

    ç”¨æˆ·->>AgentLoop: processDirect(æ¶ˆæ¯)
    
    AgentLoop->>ä¼šè¯ç®¡ç†: getOrCreate(sessionKey)
    ä¼šè¯ç®¡ç†-->>AgentLoop: è¿”å›ä¼šè¯
    
    AgentLoop->>AgentLoop: æ„å»ºæ¶ˆæ¯åˆ—è¡¨
    Note over AgentLoop: [ç³»ç»Ÿæç¤º, å†å²æ¶ˆæ¯, å½“å‰æ¶ˆæ¯]
    
    loop æœ€å¤š N æ¬¡å¾ªç¯
        AgentLoop->>LLM: chat(æ¶ˆæ¯, å·¥å…·å®šä¹‰)
        LLM-->>AgentLoop: å“åº” (å«å·¥å…·è°ƒç”¨æˆ–ç›´æ¥å›å¤)
        
        alt LLM è¯·æ±‚å·¥å…·è°ƒç”¨
            AgentLoop->>å·¥å…·æ³¨å†Œ: execute(å·¥å…·å, å‚æ•°)
            å·¥å…·æ³¨å†Œ-->>AgentLoop: å·¥å…·æ‰§è¡Œç»“æœ
            
            AgentLoop->>AgentLoop: å°†ç»“æœåŠ å…¥æ¶ˆæ¯å†å²
            Note over AgentLoop: ç»§ç»­å¾ªç¯
        else LLM ç›´æ¥å›å¤
            Note over AgentLoop: é€€å‡ºå¾ªç¯
        end
    end
    
    AgentLoop->>ä¼šè¯ç®¡ç†: save(ä¼šè¯)
    AgentLoop-->>ç”¨æˆ·: è¿”å›æœ€ç»ˆå›å¤
```

---

### 2.2 LLM æä¾›å•†ç³»ç»Ÿ

**æ–‡ä»¶ä½ç½®**: `src/providers/`

#### 2.2.1 æ¶æ„è®¾è®¡

nanobot ä½¿ç”¨**æ¥å£æŠ½è±¡**çš„æ–¹å¼æ¥æ”¯æŒå¤šç§ LLM æä¾›å•†ï¼š

```mermaid
classDiagram
    class LLMProvider {
        <<abstract>>
        +apiKey: string
        +apiBase: string
        +chat(options: ChatOptions) Promise~LLMResponse~
        +getDefaultModel() string
    }
    
    class AnthropicProvider {
        +chat(options: ChatOptions) Promise~LLMResponse~
        +getDefaultModel() string
    }
    
    class OpenAIProvider {
        +chat(options: ChatOptions) Promise~LLMResponse~
        +getDefaultModel() string
    }
    
    LLMProvider <|-- AnthropicProvider
    LLMProvider <|-- OpenAIProvider
```

#### 2.2.2 åŸºç¡€æ¥å£ (base.ts)

```typescript
/**
 * å·¥å…·è°ƒç”¨è¯·æ±‚
 * å½“ LLM è¯·æ±‚è°ƒç”¨å·¥å…·æ—¶ä½¿ç”¨
 */
export interface ToolCallRequest {
  id: string;                    // å”¯ä¸€æ ‡è¯†ç¬¦
  name: string;                  // å·¥å…·åç§°
  arguments: Record<string, unknown>;  // å·¥å…·å‚æ•°
}

/**
 * LLM å“åº”
 * LLM è¿”å›çš„æ•°æ®ç»“æ„
 */
export interface LLMResponse {
  content: string | null;        // æ–‡æœ¬å†…å®¹
  toolCalls: ToolCallRequest[];  // å·¥å…·è°ƒç”¨åˆ—è¡¨
  finishReason: string;           // ç»“æŸåŸå› 
  usage: Record<string, number>;  // token ä½¿ç”¨é‡
}

/**
 * æ¶ˆæ¯ç»“æ„
 * å¯¹è¯ä¸­çš„æ¯æ¡æ¶ˆæ¯
 */
export interface Message {
  role: "system" | "user" | "assistant" | "tool";  // å‘é€è€…è§’è‰²
  content: string;                 // æ¶ˆæ¯å†…å®¹
  toolCallId?: string;             // å·¥å…·è°ƒç”¨ IDï¼ˆä»…å·¥å…·æ¶ˆæ¯ï¼‰
  toolName?: string;               // å·¥å…·åç§°ï¼ˆä»…å·¥å…·æ¶ˆæ¯ï¼‰
}

/**
 * èŠå¤©é€‰é¡¹
 * è°ƒç”¨ LLM æ—¶éœ€è¦çš„å‚æ•°
 */
export interface ChatOptions {
  messages: Message[];             // æ¶ˆæ¯åˆ—è¡¨
  tools?: ToolDefinition[];        // å¯ç”¨å·¥å…·å®šä¹‰
  model?: string;                  // æ¨¡å‹åç§°
  maxTokens?: number;              // æœ€å¤§ token æ•°
  temperature?: number;            // é‡‡æ ·æ¸©åº¦
}

/**
 * æŠ½è±¡åŸºç±»: LLMProvider
 * æ‰€æœ‰ LLM æä¾›å•†éƒ½è¦ç»§æ‰¿è¿™ä¸ªç±»
 */
export abstract class LLMProvider {
  // å—ä¿æŠ¤çš„æˆå‘˜å˜é‡ï¼ˆå­ç±»å¯ä»¥è®¿é—®ï¼‰
  protected apiKey: string | null;      // API å¯†é’¥
  protected apiBase: string | null;     // API åŸºç¡€ URL
  
  // æ„é€ å‡½æ•°
  constructor(apiKey: string | null = null, apiBase: string | null = null) {
    this.apiKey = apiKey;
    this.apiBase = apiBase;
  }
  
  /**
   * å‘é€èŠå¤©è¯·æ±‚ï¼ˆæŠ½è±¡æ–¹æ³•ï¼Œå­ç±»å¿…é¡»å®ç°ï¼‰
   */
  abstract chat(options: ChatOptions): Promise<LLMResponse>;
  
  /**
   * è·å–é»˜è®¤æ¨¡å‹ï¼ˆæŠ½è±¡æ–¹æ³•ï¼Œå­ç±»å¿…é¡»å®ç°ï¼‰
   */
  abstract getDefaultModel(): string;
  
  /**
   * æ£€æŸ¥å“åº”æ˜¯å¦åŒ…å«å·¥å…·è°ƒç”¨
   */
  hasToolCalls(response: LLMResponse): boolean {
    return response.toolCalls.length > 0;
  }
}
```

#### 2.2.3 Anthropic æä¾›å•†å®ç°

**æ–‡ä»¶ä½ç½®**: `src/providers/anthropic.ts`

```typescript
/**
 * Anthropic æä¾›å•†
 * ä½¿ç”¨ Bun åŸç”Ÿ fetch è°ƒç”¨ Claude API
 */
export class AnthropicProvider extends LLMProvider {
  // é»˜è®¤æ¨¡å‹
  protected defaultModel: string = "claude-sonnet-4-20250514";
  
  /**
   * å‘é€èŠå¤©è¯·æ±‚
   * æ ¸å¿ƒæ–¹æ³•ï¼šå°†è¯·æ±‚å‘é€åˆ° Anthropic API å¹¶å¤„ç†å“åº”
   */
  async chat(options: ChatOptions): Promise<LLMResponse> {
    const model = options.model || this.defaultModel;
    const maxTokens = options.maxTokens ?? 4096;
    const temperature = options.temperature ?? 0.7;
    
    // 1. å°†æ¶ˆæ¯è½¬æ¢ä¸º Anthropic æ ¼å¼
    const anthropicMessages = this._convertMessages(options.messages);
    
    // 2. å°†å·¥å…·å®šä¹‰è½¬æ¢ä¸º Anthropic æ ¼å¼
    const anthropicTools: AnthropicTool[] | undefined = options.tools
      ? this._convertTools(options.tools)
      : undefined;
    
    try {
      // 3. å‘é€è¯·æ±‚
      const response = await this._makeRequest({
        model,
        maxTokens,
        messages: anthropicMessages,
        tools: anthropicTools,
        temperature,
      });
      
      // 4. è§£æå“åº”
      return this._parseResponse(response);
    } catch (error) {
      // é”™è¯¯å¤„ç†
      const errorMessage = error instanceof Error ? error.message : String(error);
      return {
        content: `Error calling Anthropic: ${errorMessage}`,
        toolCalls: [],
        finishReason: "error",
        usage: {},
      };
    }
  }
  
  /**
   * å‘é€ HTTP è¯·æ±‚åˆ° Anthropic API
   * ä½¿ç”¨ Bun çš„ fetch APIï¼ˆæµè§ˆå™¨å’Œ Node éƒ½æ”¯æŒï¼‰
   */
  private async _makeRequest(params: {
    model: string;
    maxTokens: number;
    messages: AnthropicMessage[];
    tools?: AnthropicTool[];
    temperature: number;
  }): Promise<AnthropicResponse> {
    // æ„å»ºè¯·æ±‚å¤´
    const headers: Record<string, string> = {
      "Content-Type": "application/json",
      "anthropic-version": ANTHROPIC_API_VERSION,  // "2023-06-01"
    };
    
    // æ·»åŠ è®¤è¯ä¿¡æ¯
    if (this.apiKey) {
      if (this.authType === "bearer") {
        headers["Authorization"] = `Bearer ${this.apiKey}`;
      } else {
        headers["x-api-key"] = this.apiKey;
      }
    }
    
    // æ„å»ºè¯·æ±‚ä½“
    const body: Record<string, unknown> = {
      model: params.model,
      max_tokens: params.maxTokens,
      messages: params.messages,
      temperature: params.temperature,
    };
    
    // æ·»åŠ å·¥å…·å®šä¹‰ï¼ˆå¦‚æœæœ‰ï¼‰
    if (params.tools && params.tools.length > 0) {
      body.tools = params.tools;
    }
    
    // ç¡®å®š API åŸºç¡€ URL
    let apiBase = this.apiBase || ANTHROPIC_API_BASE;
    if (apiBase && !apiBase.endsWith("/v1/messages")) {
      apiBase = apiBase.replace(/\/$/, "") + "/v1/messages";
    }
    
    // å‘é€è¯·æ±‚
    const response = await fetch(apiBase, {
      method: "POST",
      headers,
      body: JSON.stringify(body),
    });
    
    // æ£€æŸ¥å“åº”çŠ¶æ€
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Anthropic API Error (${response.status}): ${errorText}`);
    }
    
    return response.json() as Promise<AnthropicResponse>;
  }
  
  /**
   * è§£æ Anthropic å“åº”
   * å°† Anthropic æ ¼å¼è½¬æ¢ä¸ºç»Ÿä¸€æ ¼å¼
   */
  private _parseResponse(response: AnthropicResponse): LLMResponse {
    let content = "";
    const toolCalls: ToolCallRequest[] = [];
    
    // éå†å“åº”å†…å®¹å—
    for (const block of response.content) {
      if (block.type === "text") {
        // æ–‡æœ¬å—
        content = (block as AnthropicTextBlock).text;
      }
      else if (block.type === "tool_use") {
        // å·¥å…·è°ƒç”¨å—
        const toolBlock = block as AnthropicToolUseBlock;
        toolCalls.push({
          id: toolBlock.id,
          name: toolBlock.name,
          arguments: toolBlock.input,
        });
      }
    }
    
    return {
      content,
      toolCalls,
      finishReason: this._getFinishReason(response.stop_reason),
      usage: {
        promptTokens: response.usage.input_tokens,
        completionTokens: response.usage.output_tokens,
        totalTokens: response.usage.input_tokens + response.usage.output_tokens,
      },
    };
  }
  
  getDefaultModel(): string {
    return this.defaultModel;
  }
}
```

---

### 2.3 å·¥å…·ç³»ç»Ÿ

**æ–‡ä»¶ä½ç½®**: `src/tools/`

#### 2.3.1 æ¶æ„æ¦‚è¿°

```mermaid
classDiagram
    class Tool {
        <<abstract>>
        +name: string
        +description: string
        +parameters: Record~string, unknown~
        +execute(params) Promise~string~
        +toSchema() Record~string, unknown~
    }
    
    class ToolRegistry {
        -tools: Map~string, Tool~
        +register(tool)
        +unregister(name)
        +get(name)
        +has(name)
        +get_definitions() ToolDefinition[]
        +execute(name, params) Promise~string~
    }
    
    class ExecTool {
        +name: string
        +description: string
        +parameters
        +execute(params)
    }
    
    class WebSearchTool {
        +name: string
        +description: string
        +parameters
        +execute(params)
    }
    
    Tool <|-- ExecTool
    Tool <|-- WebSearchTool
    ToolRegistry --> Tool
```

#### 2.3.2 å·¥å…·æ³¨å†Œä¸­å¿ƒ (registry.ts)

```typescript
/**
 * å·¥å…·æ³¨å†Œä¸­å¿ƒ
 * è´Ÿè´£ç®¡ç†æ‰€æœ‰å¯ç”¨å·¥å…·çš„æ³¨å†Œã€æŸ¥æ‰¾å’Œæ‰§è¡Œ
 * 
 * å°±åƒä¸€ä¸ª"å·¥å…·ç®±"ï¼Œæ‰€æœ‰å·¥å…·éƒ½éœ€è¦å…ˆæ³¨å†Œæ‰èƒ½ä½¿ç”¨
 */
export class ToolRegistry {
  // ä½¿ç”¨ Map å­˜å‚¨å·¥å…·ï¼Œkey æ˜¯å·¥å…·åç§°ï¼Œvalue æ˜¯å·¥å…·å®ä¾‹
  private tools: Map<string, Tool> = new Map();
  
  /**
   * æ³¨å†Œå·¥å…·
   * å°†å·¥å…·æ·»åŠ åˆ°æ³¨å†Œä¸­å¿ƒ
   * 
   * @param tool - å·¥å…·å®ä¾‹
   */
  register(tool: Tool): void {
    // ä»¥å·¥å…·åç§°ä¸º key å­˜å‚¨
    this.tools.set(tool.name, tool);
  }
  
  /**
   * ç§»é™¤å·¥å…·
   * æ ¹æ®åç§°ç§»é™¤å·²æ³¨å†Œçš„å·¥å…·
   * 
   * @param name - å·¥å…·åç§°
   */
  unregister(name: string): void {
    this.tools.delete(name);
  }
  
  /**
   * è·å–å·¥å…·
   * æ ¹æ®åç§°æŸ¥æ‰¾å·¥å…·
   * 
   * @param name - å·¥å…·åç§°
   * @returns å·¥å…·å®ä¾‹ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™è¿”å› undefined
   */
  get(name: string): Tool | undefined {
    return this.tools.get(name);
  }
  
  /**
   * æ£€æŸ¥å·¥å…·æ˜¯å¦å­˜åœ¨
   * 
   * @param name - å·¥å…·åç§°
   * @returns æ˜¯å¦å­˜åœ¨
   */
  has(name: string): boolean {
    return this.tools.has(name);
  }
  
  /**
   * è·å–æ‰€æœ‰å·¥å…·å®šä¹‰
   * ç”¨äºå‘é€ç»™ LLMï¼Œè®© LLM çŸ¥é“æœ‰å“ªäº›å·¥å…·å¯ç”¨
   * 
   * @returns å·¥å…·å®šä¹‰æ•°ç»„
   */
  get_definitions(): ToolDefinition[] {
    const definitions: ToolDefinition[] = [];
    // éå†æ‰€æœ‰å·¥å…·ï¼Œæå–å®šä¹‰
    for (const tool of this.tools.values()) {
      definitions.push({
        name: tool.name,
        description: tool.description,
        parameters: tool.parameters,
      });
    }
    return definitions;
  }
  
  /**
   * æ‰§è¡Œå·¥å…·
   * æ ¹æ®åç§°å’Œå‚æ•°æ‰§è¡Œå·¥å…·
   * 
   * @param name - å·¥å…·åç§°
   * @param params - å·¥å…·å‚æ•°
   * @returns å·¥å…·æ‰§è¡Œç»“æœï¼ˆå­—ç¬¦ä¸²å½¢å¼ï¼‰
   */
  async execute(name: string, params: Record<string, unknown>): Promise<string> {
    // 1. æŸ¥æ‰¾å·¥å…·
    const tool = this.get(name);
    if (!tool) {
      return `Error: Tool '${name}' not found`;
    }
    
    // 2. æ‰§è¡Œå·¥å…·å¹¶è¿”å›ç»“æœ
    try {
      const result = await tool.execute(params);
      return result;
    } catch (error) {
      return `Error executing ${name}: ${error}`;
    }
  }
  
  /**
   * è·å–æ‰€æœ‰å·²æ³¨å†Œå·¥å…·çš„åç§°
   */
  get tool_names(): string[] {
    return Array.from(this.tools.keys());
  }
  
  /**
   * è·å–å·²æ³¨å†Œå·¥å…·çš„æ•°é‡
   */
  get length(): number {
    return this.tools.size;
  }
}
```

#### 2.3.3 Shell å·¥å…·å®ç° (shell.ts)

```typescript
import { Tool } from "../providers/base";

/**
 * ExecTool - æ‰§è¡Œ Shell å‘½ä»¤çš„å·¥å…·
 * 
 * è¿™ä¸ªå·¥å…·å…è®¸ Agent æ‰§è¡Œç³»ç»Ÿå‘½ä»¤ï¼Œå¦‚ ls, git, npm ç­‰
 */
export class ExecTool extends Tool {
  // å·¥å…·åç§°ï¼ˆLLM è°ƒç”¨æ—¶ä½¿ç”¨ï¼‰
  name = "exec";
  
  // å·¥å…·æè¿°ï¼ˆå‘Šè¯‰ LLM è¿™ä¸ªå·¥å…·èƒ½åšä»€ä¹ˆï¼‰
  description = "Execute a shell command and return its output. Use with caution.";
  
  // å‚æ•°å®šä¹‰ï¼ˆJSON Schema æ ¼å¼ï¼‰
  parameters: Record<string, unknown> = {
    type: "object",
    properties: {
      // command å‚æ•°ï¼šå¿…é¡»æä¾›çš„-shell å‘½ä»¤
      command: { 
        type: "string", 
        description: "The shell command to execute" 
      },
      // working_dir å‚æ•°ï¼šå¯é€‰çš„å·¥ä½œç›®å½•
      working_dir: { 
        type: "string", 
        description: "Optional working directory for the command" 
      }
    },
    required: ["command"]  // command æ˜¯å¿…éœ€å‚æ•°
  };

  // æ„é€ å‡½æ•°
  constructor(
    private timeout: number = 60,           // è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤ 60 ç§’
    private workingDir: string = process.cwd()  // é»˜è®¤å·¥ä½œç›®å½•
  ) {
    super();  // è°ƒç”¨çˆ¶ç±»æ„é€ å‡½æ•°
  }

  /**
   * æ‰§è¡Œå·¥å…·
   * 
   * @param params - åŒ…å« command å’Œå¯é€‰çš„ working_dir
   * @returns å‘½ä»¤æ‰§è¡Œç»“æœ
   */
  async execute(params: Record<string, unknown>): Promise<string> {
    // 1. è·å–å‚æ•°
    const command = params.command as string;
    const workingDir = (params.working_dir as string) || this.workingDir;
    
    // 2. å‚æ•°éªŒè¯
    if (!command) {
      return "Error: Missing required parameter 'command'";
    }
    
    // 3. ä½¿ç”¨ Bun çš„ spawn æ‰§è¡Œå‘½ä»¤
    // Bun.spawn æ˜¯ Bun æä¾›çš„å¼‚æ­¥è¿›ç¨‹æ‰§è¡Œå‡½æ•°
    const proc = Bun.spawn({
      cmd: ["/bin/sh", "-c", command],  // é€šè¿‡ shell æ‰§è¡Œå‘½ä»¤
      cwd: workingDir,                    // å·¥ä½œç›®å½•
      stdio: ["ignore", "pipe", "pipe"]  // æ ‡å‡†è¾“å…¥å¿½ç•¥ï¼Œè¾“å‡ºå’Œé”™è¯¯é€šè¿‡ç®¡é“
    });

    // 4. è¿”å› Promiseï¼Œå¤„ç†å‘½ä»¤æ‰§è¡Œç»“æœ
    return new Promise(async (resolve) => {
      // è®¾ç½®è¶…æ—¶å®šæ—¶å™¨
      const timeoutId = setTimeout(() => {
        proc.kill();  // è¶…æ—¶æ€æ­»è¿›ç¨‹
        resolve(`Error: Command timed out after ${this.timeout} seconds`);
      }, this.timeout * 1000);

      try {
        // è¯»å–æ ‡å‡†è¾“å‡ºå’Œæ ‡å‡†é”™è¯¯
        const stdoutBuffer = await Bun.readableStreamToText(proc.stdout);
        const stderrBuffer = await Bun.readableStreamToText(proc.stderr);
        
        // ç­‰å¾…è¿›ç¨‹ç»“æŸ
        const exitCode = await proc.exited;

        // æ¸…é™¤è¶…æ—¶å®šæ—¶å™¨
        clearTimeout(timeoutId);

        // æ„å»ºç»“æœå­—ç¬¦ä¸²
        let result = stdoutBuffer;
        if (stderrBuffer.trim()) {
          result += `\nSTDERR:\n${stderrBuffer}`;
        }
        if (exitCode !== 0) {
          result += `\nExit code: ${exitCode}`;
        }

        resolve(result || "(no output)");
      } catch (e) {
        clearTimeout(timeoutId);
        resolve(`Error executing command: ${(e as Error).message}`);
      }
    });
  }
}
```

---

### 2.4 ä¸Šä¸‹æ–‡æ„å»ºå™¨

**æ–‡ä»¶ä½ç½®**: `src/agent/context.ts`

```typescript
/**
 * ä¸Šä¸‹æ–‡æ„å»ºå™¨
 * è´Ÿè´£ç»„è£…å‘é€ç»™ LLM çš„ç³»ç»Ÿæç¤ºè¯
 * 
 * å°±åƒ"ç§˜ä¹¦"ä¸€æ ·ï¼Œå‡†å¤‡å¥½æ‰€æœ‰éœ€è¦çš„ä¿¡æ¯ï¼š
 * - Agent çš„èº«ä»½è®¾å®š
 * - å¯ç”¨çš„å·¥å…·
 * - å†å²è®°å¿†
 * - æŠ€èƒ½åˆ—è¡¨
 */
class ContextBuilder {
  workspace: string;
  memory: IMemoryStore;
  skills: ISkillsLoader;

  /**
   * æ„é€ å‡½æ•°
   * 
   * @param workspace - å·¥ä½œç©ºé—´è·¯å¾„
   * @param memory - è®°å¿†å­˜å‚¨ï¼ˆå¯é€‰ï¼‰
   * @param skills - æŠ€èƒ½åŠ è½½å™¨ï¼ˆå¯é€‰ï¼‰
   */
  constructor(
    workspace: string, 
    memory?: IMemoryStore | null, 
    skills?: ISkillsLoader | null
  ) {
    this.workspace = workspace;
    // å¦‚æœæ²¡æœ‰æä¾› memoryï¼Œä½¿ç”¨é»˜è®¤çš„ç©ºå®ç°
    this.memory = memory || {
      get_memory_context: () => null
    };
    
    // å¦‚æœæ²¡æœ‰æä¾› skillsï¼Œä½¿ç”¨é»˜è®¤çš„ç©ºå®ç°
    this.skills = skills || {
      get_always_skills: () => [],
      load_skills_for_context: (skills: string[]) => "",
      build_skills_summary: () => ""
    };
  }

  /**
   * æ„å»ºç³»ç»Ÿæç¤ºè¯
   * è¿™æ˜¯å‘é€ç»™ LLM çš„æœ€é‡è¦çš„ä¿¡æ¯
   * 
   * @param skillNames - å¯é€‰çš„æŠ€èƒ½åç§°åˆ—è¡¨
   * @returns å®Œæ•´çš„ç³»ç»Ÿæç¤ºè¯
   */
  buildSystemPrompt(skillNames?: string[]): string {
    const parts = [];

    // 1. æ ¸å¿ƒèº«ä»½è®¾å®š
    parts.push(this._getIdentity());

    // 2. å¼•å¯¼æ–‡ä»¶ï¼ˆAGENTS.md, SOUL.md, USER.mdï¼‰
    const bootstrap = this._loadBootstrapFiles();
    if (bootstrap) {
      parts.push(bootstrap);
    }

    // 3. è®°å¿†ä¸Šä¸‹æ–‡
    const memory = this.memory.get_memory_context();
    if (memory) {
      parts.push(`# Memory\n\n${memory}`);
    }

    // 4. æŠ€èƒ½ - æ€»æ˜¯åŠ è½½çš„æŠ€èƒ½
    const alwaysSkills = this.skills.get_always_skills();
    if (alwaysSkills.length > 0) {
      const alwaysContent = this.skills.load_skills_for_context(alwaysSkills);
      if (alwaysContent) {
        parts.push(`# Active Skills\n\n${alwaysContent}`);
      }
    }

    // 5. æŠ€èƒ½æ‘˜è¦ï¼ˆè®© Agent çŸ¥é“æœ‰å“ªäº›æŠ€èƒ½å¯ç”¨ï¼‰
    const skillsSummary = this.skills.build_skills_summary();
    if (skillsSummary) {
      parts.push(`# Skills

The following skills extend your capabilities. To use a skill, read its SKILL.md file using the read_file tool.
Skills with available="false" need dependencies installed first - you can try installing them with apt/brew.

${skillsSummary}`);
    }

    // ç”¨åˆ†éš”ç¬¦è¿æ¥æ‰€æœ‰éƒ¨åˆ†
    return parts.join("\n\n---\n\n");
  }

  /**
   * è·å–æ ¸å¿ƒèº«ä»½è®¾å®š
   * å‘Šè¯‰ LLM å®ƒæ˜¯è°ï¼Œèƒ½åšä»€ä¹ˆ
   */
  _getIdentity(): string {
    const now = new Date();
    const formattedDateTime = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')} (${now.toLocaleDateString('en-US', { weekday: 'long' })})`;
    const workspacePath = this.workspace;

    return `# nanobot ğŸˆ

You are nanobot, a helpful AI assistant. You have access to tools that allow you to:
- Read, write, and edit files
- Execute shell commands  
- Search the web and fetch web pages
- Send messages to users on chat channels
- Spawn subagents for complex background tasks

## Current Time
${formattedDateTime}

## Workspace
Your workspace is at: ${workspacePath}
- Memory files: ${workspacePath}/memory/MEMORY.md
- Daily notes: ${workspacePath}/memory/YYYY-MM-DD.md
- Custom skills: ${workspacePath}/skills/{skill-name}/SKILL.md

IMPORTANT: When responding to direct questions or conversations, reply directly with your text response.
Only use the 'message' tool when you need to send a message to a specific chat channel (like WhatsApp).
For normal conversation, just respond with text - do not call the message tool.

Always be helpful, accurate, and concise. When using tools, explain what you're doing.
When remembering something, write to ${workspacePath}/memory/MEMORY.md`;
  }

  /**
   * åŠ è½½å¼•å¯¼æ–‡ä»¶
   * ä»å·¥ä½œç©ºé—´è¯»å– AGENTS.md, SOUL.md, USER.md
   */
  _loadBootstrapFiles(): string {
    const parts = [];
    const bootstrapFiles = ["AGENTS.md", "SOUL.md", "USER.md"];

    for (const filename of bootstrapFiles) {
      const filePath = join(this.workspace, filename);
      if (existsSync(filePath)) {
        const content = readFileSync(filePath, "utf-8");
        parts.push(`## ${filename}\n\n${content}`);
      }
    }

    return parts.length > 0 ? parts.join("\n\n") : "";
  }
}
```

---

### 2.5 æ¶ˆæ¯æ€»çº¿

**æ–‡ä»¶ä½ç½®**: `src/bus/queue.ts`

```typescript
/**
 * æ¶ˆæ¯æ€»çº¿
 * è´Ÿè´£åœ¨ç³»ç»Ÿå„ç»„ä»¶ä¹‹é—´ä¼ é€’æ¶ˆæ¯
 * 
 * å°±åƒ"é‚®å±€"ï¼š
 * - å…¥ç«™æ¶ˆæ¯ï¼šç”¨æˆ· -> Agent
 * - å‡ºç«™æ¶ˆæ¯ï¼šAgent -> ç”¨æˆ·
 */
export class MessageBus {
  // æ¶ˆæ¯é˜Ÿåˆ—
  private inbound: InboundMessage[] = [];   // å…¥ç«™é˜Ÿåˆ—
  private outbound: OutboundMessage[] = []; // å‡ºç«™é˜Ÿåˆ—
  
  // å‡ºç«™æ¶ˆæ¯è®¢é˜…è€…
  private outboundSubscribers: Map<string, MessageHandler[]> = new Map();
  
  // è¿è¡ŒçŠ¶æ€
  private running = false;

  /**
   * å‘å¸ƒå…¥ç«™æ¶ˆæ¯
   * ç”¨æˆ·å‘é€æ¶ˆæ¯æ—¶è°ƒç”¨æ­¤æ–¹æ³•
   * 
   * @param msg - å…¥ç«™æ¶ˆæ¯
   */
  async publishInbound(msg: InboundMessage): Promise<void> {
    this.inbound.push(msg);
  }

  /**
   * æ¶ˆè´¹å…¥ç«™æ¶ˆæ¯
   * Agent ä»é˜Ÿåˆ—ä¸­è¯»å–æ¶ˆæ¯
   * å¦‚æœé˜Ÿåˆ—ä¸ºç©ºï¼Œä¼šç­‰å¾…ç›´åˆ°æœ‰æ–°æ¶ˆæ¯
   * 
   * @returns ä¸‹ä¸€æ¡å…¥ç«™æ¶ˆæ¯
   */
  async consumeInbound(): Promise<InboundMessage> {
    while (this.inbound.length === 0) {
      // é˜Ÿåˆ—ä¸ºç©ºï¼Œç­‰å¾… 100ms åé‡è¯•
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    return this.inbound.shift()!;  // å–å‡ºå¹¶ç§»é™¤ç¬¬ä¸€æ¡æ¶ˆæ¯
  }

  /**
   * å‘å¸ƒå‡ºç«™æ¶ˆæ¯
   * Agent å›å¤æ¶ˆæ¯æ—¶è°ƒç”¨æ­¤æ–¹æ³•
   * 
   * @param msg - å‡ºç«™æ¶ˆæ¯
   */
  async publishOutbound(msg: OutboundMessage): Promise<void> {
    this.outbound.push(msg);
  }

  /**
   * æ¶ˆè´¹å‡ºç«™æ¶ˆæ¯
   * é€šé“ç®¡ç†å™¨ä»é˜Ÿåˆ—ä¸­è¯»å–å›å¤å‘é€ç»™ç”¨æˆ·
   * 
   * @returns ä¸‹ä¸€æ¡å‡ºç«™æ¶ˆæ¯
   */
  async consumeOutbound(): Promise<OutboundMessage> {
    while (this.outbound.length === 0) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    return this.outbound.shift()!;
  }

  /**
   * è®¢é˜…å‡ºç«™æ¶ˆæ¯
   * ç”¨äºé€šé“ç›‘å¬ç‰¹å®šç±»å‹çš„æ¶ˆæ¯
   * 
   * @param channel - é€šé“åç§°ï¼ˆå¦‚ "feishu"ï¼‰
   * @param callback - å›è°ƒå‡½æ•°
   */
  subscribeOutbound(channel: string, callback: MessageHandler): void {
    const handlers = this.outboundSubscribers.get(channel) ?? [];
    handlers.push(callback);
    this.outboundSubscribers.set(channel, handlers);
  }

  /**
   * è·å–é˜Ÿåˆ—ä¸­çš„æ¶ˆæ¯æ•°é‡
   */
  get inboundSize(): number {
    return this.inbound.length;
  }

  get outboundSize(): number {
    return this.outbound.length;
  }
}
```

---

### 2.6 CLI å‘½ä»¤ç³»ç»Ÿ

**æ–‡ä»¶ä½ç½®**: `src/cli/commands.ts`

```typescript
// ============================================================
// ä½¿ç”¨ commander.js åº“æ„å»º CLI
// è¿™æ˜¯ä¸€ä¸ªæµè¡Œçš„ Node.js CLI æ¡†æ¶
// ============================================================
const program = new Command();

// ============================================================
// å‘½ä»¤: nanobot onboard
// åˆå§‹åŒ–é…ç½®å’Œå·¥ä½œç©ºé—´
// ============================================================
program
  .command("onboard")
  .description("Initialize nanobot configuration and workspace")
  .action(async () => {
    console.log("Initializing nanobot...\n");
    
    // 1. åŠ è½½æˆ–åˆ›å»ºé…ç½®
    const config = loadConfig();
    saveConfig(config);
    
    // 2. è·å–å·¥ä½œç©ºé—´è·¯å¾„
    const workspace = getWorkspacePath();
    
    // 3. åˆ›å»ºæ¨¡æ¿æ–‡ä»¶
    createWorkspaceTemplates(workspace);
    
    console.log("âœ“ nanobot is ready!");
  });

// ============================================================
// å‘½ä»¤: nanobot agent
// ä¸ Agent å¯¹è¯
// ============================================================
const agentCmd = program
  .command("agent")
  .description("Interact with the agent directly");

agentCmd
  .option("-m, --message <message>", "Message to send to the agent")
  .option("-s, --session <session>", "Session ID", "cli:default")
  .action(async (options) => {
    // 1. åŠ è½½é…ç½®
    const config = loadConfig();
    
    // 2. åˆ›å»º LLM æä¾›å•†
    const provider = createProvider(config);
    
    // 3. åˆ›å»º AgentLoop
    const agent = new AgentLoop(provider, config.workspacePath, {
      model: config.agents.defaults.model,
      maxIterations: config.agents.defaults.max_tool_iterations,
    });

    // 4. å¤„ç†æ¶ˆæ¯
    if (options.message) {
      // å•æ¡æ¶ˆæ¯æ¨¡å¼
      const response = await agent.processDirect(
        options.message,
        options.session
      );
      console.log("\n" + response);
    } else {
      // äº¤äº’æ¨¡å¼ï¼ˆå¾ªç¯è¯»å–è¾“å…¥ï¼‰
      while (true) {
        const input = await promptInput("You: ");
        const response = await agent.processDirect(input, options.session);
        console.log("\n" + response + "\n");
      }
    }
  });

// ============================================================
// å‘½ä»¤: nanobot gateway
// å¯åŠ¨ç½‘å…³æœåŠ¡ï¼ˆæ”¯æŒé£ä¹¦ç­‰é€šé“ï¼‰
// ============================================================
const gatewayCmd = program
  .command("gateway")
  .description("Start the nanobot gateway");

gatewayCmd
  .option("-p, --port <port>", "Gateway port", "18790")
  .action(async (options) => {
    const config = loadConfig();
    const bus = new MessageBus();
    const provider = createProvider(config);
    
    // åˆ›å»º AgentLoop
    const agent = new AgentLoop(provider, config.workspacePath, {
      model: config.agents.defaults.model,
    });
    
    // åˆ›å»ºå®šæ—¶ä»»åŠ¡æœåŠ¡
    const cron = new CronService(cronStorePath, async (job) => {
      return await agent.processDirect(
        job.payload.message,
        `cron:${job.id}`
      );
    });
    
    // åˆ›å»ºå¿ƒè·³æœåŠ¡
    const heartbeat = new HeartbeatService(
      config.workspacePath,
      async (prompt) => {
        return await agent.processDirect(prompt, "heartbeat");
      },
      30 * 60,  // 30 åˆ†é’Ÿ
      true
    );
    
    // åˆ›å»ºé€šé“ç®¡ç†å™¨ï¼ˆé£ä¹¦ç­‰ï¼‰
    const channels = new ChannelManager(config, bus);
    
    // å¯åŠ¨æ¶ˆæ¯å¤„ç†å¾ªç¯
    const messageLoop = async () => {
      while (true) {
        // 1. è¯»å–å…¥ç«™æ¶ˆæ¯
        const inboundMsg = await bus.consumeInbound();
        
        // 2. å¤„ç†æ¶ˆæ¯
        const response = await agent.processDirect(
          inboundMsg.content,
          getSessionKey(inboundMsg)
        );
        
        // 3. å‘å¸ƒå‡ºç«™æ¶ˆæ¯
        await bus.publishOutbound({
          channel: inboundMsg.channel,
          chatId: inboundMsg.chatId,
          content: response,
        });
      }
    };
    
    messageLoop();
  });

// ============================================================
// å‘½ä»¤: nanobot cron
// ç®¡ç†å®šæ—¶ä»»åŠ¡
// ============================================================
const cronCmd = program.command("cron").description("Manage scheduled tasks");

// nanobot cron list - åˆ—å‡ºæ‰€æœ‰ä»»åŠ¡
cronCmd
  .command("list")
  .description("List scheduled jobs")
  .action(() => {
    const service = new CronService(storePath);
    const jobs = service.listJobs();
    // æ‰“å°ä»»åŠ¡åˆ—è¡¨
  });

// nanobot cron add - æ·»åŠ ä»»åŠ¡
cronCmd
  .command("add")
  .description("Add a scheduled job")
  .requiredOption("-n, --name <name>", "Job name")
  .requiredOption("-m, --message <message>", "Message for agent")
  .option("-e, --every <seconds>", "Run every N seconds")
  .option("-c, --cron <expression>", 'Cron expression')
  .action((options) => {
    const service = new CronService(storePath);
    // æ·»åŠ ä»»åŠ¡
  });
```

---

## 3. ä»£ç é£æ ¼æ€»ç»“

### 3.1 TypeScript ç‰¹æ€§ä½¿ç”¨

| ç‰¹æ€§ | ç¤ºä¾‹ | è¯´æ˜ |
|------|------|------|
| æ¥å£ (interface) | `ToolCallRequest` | å®šä¹‰æ•°æ®ç»“æ„ |
| æŠ½è±¡ç±» (abstract class) | `LLMProvider`, `Tool` | å®šä¹‰åŸºç±» |
| æ³›å‹ (Generics) | `Promise<LLMResponse>` | ç±»å‹å®‰å…¨ |
| è®¿é—®ä¿®é¥°ç¬¦ | `private`, `protected` | å°è£…æ€§ |
| å¯é€‰å±æ€§ | `toolCallId?: string` | å‚æ•°å¯é€‰ |
| ç±»å‹æ¨å¯¼ | `const tool = this.tools.get(name)` | è‡ªåŠ¨æ¨æ–­ç±»å‹ |

### 3.2 å‘½åè§„èŒƒ

- **ç±»å**: PascalCase (å¦‚ `AgentLoop`, `ToolRegistry`)
- **æ–¹æ³•å**: camelCase (å¦‚ `processDirect`, `get_definitions`)
- **ç§æœ‰æˆå‘˜**: ä¸‹åˆ’çº¿å‰ç¼€ (å¦‚ `_registerDefaultTools`)
- **å¸¸é‡**: å…¨å¤§å†™ (å¦‚ `DEFAULT_HEARTBEAT_INTERVAL_S`)

### 3.3 æ³¨é‡Šè§„èŒƒ

```typescript
/**
 * æ–¹æ³•æè¿°
 * 
 * è¯¦ç»†è¯´æ˜
 * 
 * @param å‚æ•°å - å‚æ•°è¯´æ˜
 * @returns è¿”å›å€¼è¯´æ˜
 */
async processDirect(content: string): Promise<string> {
  // è¡Œå†…æ³¨é‡Šï¼šè§£é‡Šå¤æ‚é€»è¾‘
}
```

---

## 4. æ€»ç»“

æœ¬æ–‡æ¡£è¯¦ç»†åˆ†æäº† nanobot é¡¹ç›®çš„ä»£ç æ¶æ„ï¼š

1. **Agent Loop** - æ ¸å¿ƒå¾ªç¯å¼•æ“ï¼Œåè°ƒ LLM å’Œå·¥å…·
2. **LLM æä¾›å•†** - æŠ½è±¡æ¥å£ï¼Œæ”¯æŒ Anthropic å’Œ OpenAI
3. **å·¥å…·ç³»ç»Ÿ** - æ³¨å†Œä¸­å¿ƒæ¨¡å¼ï¼Œæ”¯æŒå¤šç§å·¥å…·
4. **ä¸Šä¸‹æ–‡æ„å»º** - ç»„è£…ç³»ç»Ÿæç¤ºè¯
5. **æ¶ˆæ¯æ€»çº¿** - ç»„ä»¶é—´é€šä¿¡
6. **CLI ç³»ç»Ÿ** - ç”¨æˆ·å‘½ä»¤è¡Œå…¥å£

æ¯ä¸ªæ¨¡å—éƒ½é‡‡ç”¨äº†æ¸…æ™°çš„è®¾è®¡æ¨¡å¼ï¼š
- æŠ½è±¡åŸºç±»ï¼ˆProvider, Toolï¼‰
- æ³¨å†Œä¸­å¿ƒæ¨¡å¼ï¼ˆToolRegistryï¼‰
- å¾ªç¯å¤„ç†æ¨¡å¼ï¼ˆAgent Loopï¼‰
- æ¶ˆæ¯é˜Ÿåˆ—æ¨¡å¼ï¼ˆMessageBusï¼‰

è¿™äº›è®¾è®¡ä½¿å¾—ä»£ç æ˜“äºç†è§£ã€æ‰©å±•å’Œç»´æŠ¤ã€‚
